---
title: 终于明白了 JavaScript 中的 this 是什么
date: 2016-12-14 14:50:38
tags:
  - this
  - js
  - JavaScript
categories: front-end
---

## 1. 相关概念

在认识 `this` 之前，需要了解与之相关的几个概念。

### 1.1 词法作用域

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 **词法作用域**，JavaScript 使用的就是词法作用域。另一种叫做 **动态作用域**，Bash 脚本在使用它。

简单地说，词法作用域就是在写代码时将变量和块作用域写在哪里来决定的。在 JavaScript 中，词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及如何声明的，从而能够预测在执行过程中如何对它们进行查找。

### 1.2 执行环境

**执行环境**（execution context）是 JavaScript 中最重要的一个概念。执行环境定义了变量或函数有权访问的其它数据，决定了它们各自的行为。每个执行环境都有一个与之关联的 **变量对象**（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在访问数据时会在后台使用它。

每个函数都有自己的 **执行环境**。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行完成后，栈将其环境弹出，把控制权交给之前的执行环境。

全局执行环境是最外围的执行环境，在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。

### 1.3 作用域链

当代码在一个环境中执行时，会创建变量对象的一个 **作用域链**（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其 **活动对象**（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象来自下一个包含环境。这样，一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。

### 1.4 构造函数

JavaScript 中 new 的机制与 Java 等面向类的语言完全不同。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。

举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它：

> 当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。

所以，包括内置对象函数在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。

实际上，并不存在所谓的“构造函数”，只有对于函数的“构造调用”。

使用 new 来调用函数，会自动执行下面的操作:

1. 创建一个全新的对象。
2. 这个新对象会被执行 [[原型]] 连接。
3. 这个新对象会绑定到函数调用的 this。
4. 如果函数没有返回其它对象，那么 new 表达式中的函数调用会自动返回这个新对象。


## 2. this 到底是什么

了解了上述概念，我们就可以解释 JavaScript 中的 this 到底是什么，以及它是如何工作的了。

当一个函数被调用时，会创建一个执行环境。其中包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是其中的一个属性，会在函数执行的过程中用到。

this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。它指向什么完全取决于函数在哪里被调用。

### 2.1 绑定规则

在 `JavaScript` 中，函数调用有以下四种方式：

```JavaScript
// 1. 全局作用域中，独立函数调用
foo(p1, p2);
// 2. 调用对象的方法
obj.foo(p1, p2);
// 3. 使用 call 或 apply
foo.call(context, p1, p2);
// 4. 构造函数调用
var obj = new foo(p1, p2);
```

因此，this 也就有四种绑定规则。

#### 2.1.1 默认绑定

首先要介绍的是最常见的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其它规则时的默认规则。

思考一下下面的代码：

```JavaScript
function foo() {
  console.log(this.a);
}
var a = 2;
foo();  // 2
```

声明在全局作用域中的变量或函数，就是全局对象的一个同名属性或方法。

当调用 foo() 时，我们看到 this.a 被解析为全局变量 a。为什么？因为本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。

如果使用严格模式，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined。

#### 2.1.2 隐式绑定

当函数引用拥有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。

```JavaScript
function foo() {
  console.log(this.a);
}
var obj = {
  a: 2,
  foo: foo
};
obj.foo(); // 2
```

这里，this.a 相当于 obj.a。

##### 2.1.2.1 隐式丢失

一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定。

```JavaScript
function foo() {
  console.log(this.a);
}
var obj = {
  a: 2,
  foo: foo
};
var bar = obj.foo;
var a = 'oops, global';
bar(); // 'oops, global'
```

虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 是一个不带任何修饰的函数调用，因此应用了默认绑定。

#### 2.1.3 显示绑定

JavaScript 提供的绝大多数函数和我们自己定义的所有函数都可以使用 call() 和 apply() 方法。它们的第一个参数是一个对象，它们会把这个对象绑定到 this ，接着在调用函数时指定这个 this 。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。

#### 2.1.4 new 绑定

思考下面的代码，

```JavaScript
function foo(a) {
  this.a = a;
}
var bar = new foo(2);
console.log(bar.a); // 2
```

使用 new 来调用函数时，我们构造一个新对象并把它绑定到 foo() 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。

### 2.2 判断 this

可以按照下面的顺序来进行判断：

1. 函数是否在 new 中调用（ new 绑定）？如果是的话 this 绑定的是新创建的对象。
```JavaScript
var bar = new foo();
```

2. 函数是否通过 call、apply（显式绑定）调用？如果是的话，this 绑定的是指定的对象。
```JavaScript
var bar = foo.call(obj2);
```

3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， this 绑定的是那个上下文对象。
```JavaScript
var bar = obj.foo();
```

4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined ，否则绑定到全局对象。
```JavaScript
var bar = foo();
```

就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。
